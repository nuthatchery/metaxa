%% Statements.sdf is part of Magnolia
%%
%% Copyright (C) 2008,2009  Anya Helene Bagge
%% Copyright (C) 2008,2009  University of Bergen
%%
%% Contact: <magnolia@magnolia-lang.org>
%%
%% This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program.  If not, see <http://www.gnu.org/licenses/>.
module Magnolia/Core/Statements
  
exports
  sorts
    BlockStat
    Stat
    LetClause
    ProcName
    Expr  %% External
    Type  %% External
    Identifier  %% External

  context-free syntax

    "{" Stat* "}" -> BlockStat {cons("Block")}

    BlockStat -> Stat

    ";" -> Stat {cons("Nop")}

     
    "if" Expr "then" Stat* "else" Stat* "end" -> Stat {prefer, cons("If")}

    "while" Expr "do" Stat* "end" -> Stat {cons("While")}

    "open" {Identifier ","}* "in" Stat* "end" -> Stat {cons("Open")}

    "for" Identifier "in" Expr "do" Stat* "end" -> Stat {cons("For")}

    "call" Proc "(" {Expr ","}* ")" ";" -> Stat {cons("Call")}

    ProcName -> Proc {cons("Proc")}

    "yield" Expr ";" -> Stat {cons("Yield")}

    "break" ";" -> Stat {cons("Break")}

    "return" ";" -> Stat {cons("Return")}

    "return" Expr ";" -> Stat {cons("Return")}

    Expr "=" Expr ";" -> Stat {cons("Assign")}

    "let" LetClause* "in" Stat* "end" -> Stat {cons("Let")}

    "var" Identifier ":" Type "=" Expr ";" -> LetClause {cons("VarDef")}

    "assert" Expr AssertClause* ";" -> Stat {cons("Assert")}

    "by" Expr -> AssertClause {cons("By")}

    "by" "simplify" Expr -> AssertClause {cons("By")}

    "qed" -> AssertClause {cons("QED")}

lexical restrictions

  "if"		-/- [A-Za-z\_\$0-9]
  "then" 	-/- [A-Za-z\_\$0-9]
  "else" 	-/- [A-Za-z\_\$0-9]
  "end" 	-/- [A-Za-z\_\$0-9]
  "while" 	-/- [A-Za-z\_\$0-9]
  "do"		-/- [A-Za-z\_\$0-9]
  "open" 	-/- [A-Za-z\_\$0-9]
  "for" 	-/- [A-Za-z\_\$0-9]
  "call" 	-/- [A-Za-z\_\$0-9]
  "yield" 	-/- [A-Za-z\_\$0-9]
  "break" 	-/- [A-Za-z\_\$0-9]
  "return" 	-/- [A-Za-z\_\$0-9]
  "let" 	-/- [A-Za-z\_\$0-9]
  "in"		-/- [A-Za-z\_\$0-9]
  "var" 	-/- [A-Za-z\_\$0-9]
  "assert" 	-/- [A-Za-z\_\$0-9]
  "by"		-/- [A-Za-z\_\$0-9]
  "simplify" 	-/- [A-Za-z\_\$0-9]
  "qed" 	-/- [A-Za-z\_\$0-9]
