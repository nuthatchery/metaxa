%% Declarations.sdf is part of Magnolia
%%
%% Copyright (C) 2008,2009  Anya Helene Bagge
%% Copyright (C) 2008,2009  University of Bergen
%%
%% Contact: <magnolia@magnolia-lang.org>
%%
%% This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program.  If not, see <http://www.gnu.org/licenses/>.

%% This module defines the common declaration syntax for Magnolia. The main 
%% non-terminal is
%%
%%   Decl -- a full, semicolon-terminated declaration.
%%
%% A declaration consists of one or more clauses. The main clause starts
%% with a keyword identifying the declaration. Additional (subordinate)
%% clauses follow the main clause, and declarations can commonly have
%% zero or more of them, the exact kinds depending on the declaration.
%%
%%   _Clause   -- the main part of a declaration, should contain whatever
%%       information uniquely identifies the declared symbol
%%   _SubClause -- a sub-clause with additional information about a decl
%%
%% Some clauses additionally contain a list of specifiers.
%%
%%   _Spec   -- a particular item in clause
%%
%% The structure of a declaration is:
%%
%%  MainClause SubClauses Definition? -> Decl
%%
%% The AttrSubClause is common to all declarations, and is the place for
%% any extra associated information that we do not want to create
%% special syntax for.
%%
%% It may be preferable (for error management) to allow all subclauses for
%% all declarations in the grammar, and then complain about them in the
%% subsequent analysis.

module Magnolia/Core/Declarations


exports

%%% Declaration and definition sentences

  sorts
	Decl		SubClause
	StatDeclarative ExprDeclarative
	TypeDeclarative	%% DeclDeclarative 

  %% Externals
	BlockStat	Expr
	Type		DataRep
	Name

  context-free syntax

    Modifier* StatDeclarative SubClause* BlockStat
	-> BraceDecl
		{cons("DefDecl")}

    Modifier* ExprDeclarative SubClause* "=" Expr ";"
	-> SemiDecl
		{cons("DefDecl")}

    Modifier* TypeDeclarative SubClause* "=" Type ";"
	-> Decl
		{cons("DefDecl")}

    Modifier* DeclDeclarative SubClause* DeclBody
	-> BraceDecl
		{cons("DefDecl")}

    "{" Decl* "}" -> DeclBody {cons("DeclBody"), dummy}

    SemiDecl -> Decl {abstract}

    BraceDecl -> Decl {abstract}

	"external" -> SubClause
	
	"default" -> Modifier
	
	"abstract" -> Modifier
	
%%% Procedure Declarations
  sorts
    ProcClause ProcName ProcIdentifier

  context-free syntax

    "procedure" ProcIdentifier ProcedureParamList
	-> ProcClause
		{cons("ProcClause")}

    ProcClause -> StatDeclarative

    Identifier -> ProcIdentifier

	Name -> ProcName
	
    "_=_" -> ProcIdentifier {cons("Assign")}

  lexical restrictions

    "procedure"		-/- [A-Za-z\_\$0-9]
    "_=_"		-/- [A-Za-z\_\$0-9]

%%% Function Declarations
  sorts
    FunClause FunName FunIdentifier

  context-free syntax

    "function" FunIdentifier FunctionParamList ":" Type
	-> FunClause			{cons("FunClause")}

    FunClause -> ExprDeclarative

	Identifier -> FunIdentifier
	
	Name -> FunName
	
  lexical restrictions

    "function"		-/- [A-Za-z\_\$0-9]

%%% Predicate Declarations
  sorts
    PredClause PredName

  context-free syntax

    "predicate" FunIdentifier FunctionParamList
	-> PredClause			{cons("PredClause")}

    PredClause -> ExprDeclarative

  lexical restrictions

    "predicate"		-/- [A-Za-z\_\$0-9]


%%% Axiom Declarations
  sorts
    AxiomClause AxiomName AxiomIdentifier

  context-free syntax

    "axiom" Identifier FunctionParamList
	-> AxiomClause			{cons("AxiomClause")}

    "theorem" Identifier FunctionParamList
	-> AxiomClause			{cons("AxiomClause")}

    "proof" Identifier FunctionParamList
	-> AxiomClause			{cons("AxiomClause")}

    AxiomClause -> StatDeclarative

    Name -> AxiomName
    
    Identifier -> AxiomIdentifier

  lexical restrictions

    "axiom"		-/- [A-Za-z\_\$0-9]
    "proof"		-/- [A-Za-z\_\$0-9]

%%% Parameters and Parameter Modes
  sorts
	TypeParamList TypeParam
	FunctionParamList FunctionParam
	ProcedureParamList ProcedureParam
	ParamMode

  context-free syntax

   %% "(" {TypeParam ","}* ")"	-> TypeParamList	{cons("Dummy")}

    "(" {FunctionParam ","}* ")"-> FunctionParamList	{cons("Dummy")}

    "(" {ProcedureParam ","}* ")"-> ProcedureParamList	{cons("Dummy")}

   %% Type			-> TypeParam		{cons("TypeExprParam")}

   %% Type Identifier		-> TypeParam		{cons("TypeExprParam")}

   %% "type"			-> TypeParam		{cons("AnonTypeParam")}

   %% "type" Identifier		-> TypeParam		{cons("TypeParam")}

   %% "type" TypeParamList	-> TypeParam		{cons("AnonTypePParam")}

   %% "type" Identifier TypeParamList -> TypeParam	{cons("TypePParam")}

    VarIdentifier ":" Type		-> FunctionParam	{cons("Param")}

    ParamMode VarIdentifier ":" Type -> ProcedureParam	{prefer, cons("Param")}

    "obs"			-> ParamMode		{cons("Obs")}
    "upd"			-> ParamMode		{cons("Upd")}
    "out"			-> ParamMode		{cons("Out")}
    "exp"			-> ParamMode		{cons("Exp")}
    "giv"			-> ParamMode		{cons("Giv")}
    "del"			-> ParamMode		{cons("Del")}
    "nrm"			-> ParamMode		{cons("Nrm")}

  lexical restrictions

    "type"		-/- [A-Za-z\_\$0-9]

    "obs"		-/- [A-Za-z\_\$0-9]
    "upd"		-/- [A-Za-z\_\$0-9]
    "out"		-/- [A-Za-z\_\$0-9]
    "exp"		-/- [A-Za-z\_\$0-9]
    "giv"		-/- [A-Za-z\_\$0-9]
    "del"		-/- [A-Za-z\_\$0-9]
    "nrm"		-/- [A-Za-z\_\$0-9]

%%% Variables

  sorts VarClause VarIdentifier VarName
  
  context-free syntax

    "var" VarIdentifier ":" Type -> VarClause {cons("VarClause")}

    VarClause -> ExprDeclarative

	Identifier -> VarIdentifier
	
	Name -> VarName
	
  lexical restrictions

    "var"		-/- [A-Za-z\_\$0-9]

%%% Types and Classes

  sorts 
	TypeClause TypeName TypeIdentifier

  context-free syntax

    "type" TypeIdentifier	-> TypeClause {cons("TypeClause")}

    TypeClause -> TypeDeclarative

	Name -> TypeName
	
	Identifier -> TypeIdentifier
	
  lexical restrictions

    "type"		-/- [A-Za-z\_\$0-9]

%%% Concepts and implementations

  sorts 
	 DeclClause

  context-free syntax

    Modifier* "concept" Identifier SubClause* "=" ConceptExpr		-> Decl {cons("ConceptClause")}
%%    "theorem" Identifier		-> DeclClause {cons("ConceptClause")}
    Modifier* "implementation" Identifier SubClause* "=" ImplExpr -> Decl {cons("ImplClause")}
 
 	Modifier* "library" Identifier SubClause* "=" ImplExpr	-> Decl {cons("Library")}

    Modifier* "concept" Identifier SubClause* DeclBody		-> Decl {deprecated("Add '=' before body"), cons("ConceptClause")}

    Modifier* "implementation" Identifier SubClause* ImplExpr -> Decl {deprecated("Add '=' before body"), cons("ImplClause")}
 
    DeclClause -> DeclDeclarative

  lexical restrictions

    "concept"		-/- [A-Za-z\_\$0-9]
%%    "theorem"		-/- [A-Za-z\_\$0-9]
    "implementation"		-/- [A-Za-z\_\$0-9]
    "library"		-/- [A-Za-z\_\$0-9]

%%% Declaration Attributes

  sorts
	AttrClause Attribute

  context-free syntax

    "[" {Attribute ","}* "]"	-> AttrClause		{cons("Attrs")}

    AttrClause -> SubClause

    Name "(" {Expr ","}* ")" -> Attribute		{cons("Attr")}


%%% Guarding

  sorts
	GuardClause

  context-free syntax

   "guard" Expr -> GuardClause {cons("Guard")}

   GuardClause -> SubClause

%%% Requires

  sorts 
    ConceptExpr MorphClause

  context-free syntax

    "requires" {ConceptExpr ","}+ ";" -> Decl	{cons("Requires")}

%% TODO: What are these supposed to be?
	"preserve" DeclBody -> Decl {todo("preserve -- Grammar needs refinement")}
	
	"congruence" DeclBody -> Decl {todo("congruence -- Grammar needs refinement")}
	
	"preserve" DeclBody "on" ConceptExpr -> Decl {todo("preserve/on -- Grammar needs refinement")}
	
	"congruence" DeclBody "on" ConceptExpr -> Decl {todo("congruence/on -- Grammar needs refinement")}
	

  lexical restrictions

    "requires"		-/- [A-Za-z\_\$0-9]
    "morphism"		-/- [A-Za-z\_\$0-9]

%%% Generated & Free

  context-free syntax

    "partition" TypeName "by" {FunClause ","}* ";" -> Decl {cons("Partition")}

    "generate" TypeName "by" {FunClause ","}* ";" -> Decl {cons("Generate")}

    "generate" TypeName "by" {Expr ","}* ";" -> Decl {cons("Generate")}

    "free" TypeName "by" {FunClause ","}* ";" -> Decl {cons("Free")}

%%% Satisfaction

  sorts
    ImplExpr ConceptExpr Morphism MorphClause

  context-free syntax


    "satisfaction" Identifier SubClause* "=" ConceptExpr WithClause? "models" ConceptExpr -> Decl {cons("ModelsImpl")}

    "satisfaction" Identifier SubClause* "=" "on" ConceptExpr WithClause? "models" ConceptExpr -> Decl {deprecated("Drop 'on'"), cons("ModelsImpl")}
    
    "with" ImplExpr -> WithClause {cons("WithClause")}

    Name -> ConceptExpr {cons("Concept")}

    DeclBody -> ConceptExpr {cons("ConceptBody")}
    
    "signature" ConceptExpr -> ConceptExpr {todo("signature -- Bruker vi denne fremdeles?"),cons("SignatureOf")}

    ConceptExpr Morphism -> ConceptExpr {cons("MorphedConcept")}

    Name -> ImplExpr  {cons("Impl")}

    ImplExpr Morphism -> ImplExpr  {cons("ImplMorph")}

    DeclBody -> ImplExpr  {cons("ImplBody")}
    
    %% TODO: Needs refinement
    
    "external" Identifier Name "defines" ImplExpr -> ImplExpr {cons("ExternalLib")}

    "external" Identifier Name "on" ConceptExpr "defines" ImplExpr -> ImplExpr {cons("ExternalLib")}

    "on" ConceptExpr "defines" ImplExpr -> ImplExpr {cons("OnDefines")}
    
%% Morphisms
context-free syntax

    "morphism" MorphClause -> Morphism  {cons("Morphism")}

    "morphism" MorphClause -> SubClause {cons("Morphism")}

	"{" MorphClause* "}" -> MorphClause {todo("clean up syntax for list of morph clauses"), cons("ImplMorphism")}
	
	"{" (MorphClause ";")* "}" -> MorphClause {todo("clean up syntax for list of morph clauses"), cons("ImplMorphism")}

    "[" {MorphClause ","}* "]" -> Morphism {cons("Morphisms")}

    Name "=>" Name -> MorphClause  {cons("Rename")}

    TypeClause "=" Type -> MorphClause	{cons("Morphism")}

    FunClause "=" Expr -> MorphClause	{cons("Morphism")}

    PredClause "=" Expr -> MorphClause	{cons("Morphism")}

    "protect" FunClause "guard" Expr -> Morphism	{cons("Protect")}

    "protect" FunClause "guard" Expr -> MorphClause	{cons("Protect")}

    "protect" FunClause "guard" Expr -> SubClause	{cons("Protect")}

    "protect" FunClause "by" Expr -> Morphism	{deprecated("Use 'guard' instead of 'by'"),cons("Protect")}

    "protect" FunClause "by" Expr -> MorphClause	{deprecated("Use 'guard' instead of 'by'"),cons("Protect")}

    "protect" FunClause "by" Expr -> SubClause	{deprecated("Use 'guard' instead of 'by'"),cons("Protect")}

%% ImplExpr
context-free syntax

	ImplExpr "@" ImplExpr 		-> ImplExpr {left, cons("At")}
	ImplExpr "@@" ImplExpr 		-> ImplExpr {left, cons("AtAt")}
	ImplExpr "*" ImplExpr 		-> ImplExpr {left, cons("Star")}
	ImplExpr "**" ImplExpr 		-> ImplExpr {left, cons("StarStar")}
	ImplExpr "+" ImplExpr 		-> ImplExpr {left, cons("Plus")}
	ImplExpr "++" ImplExpr 		-> ImplExpr {left, cons("PlusPlus")}
	ImplExpr "times" ImplExpr 	-> ImplExpr {left, cons("Times")}
	"(" ImplExpr ")" 			-> ImplExpr {bracket}

	ConceptExpr "@" ConceptExpr 	-> ConceptExpr {left, cons("At")}
	ConceptExpr "@@" ConceptExpr 	-> ConceptExpr {left, cons("AtAt")}
	ConceptExpr "*" ConceptExpr 	-> ConceptExpr {left, cons("Star")}
	ConceptExpr "**" ConceptExpr 	-> ConceptExpr {left, cons("StarStar")}
	ConceptExpr "+" ConceptExpr 	-> ConceptExpr {left, cons("Plus")}
	ConceptExpr "++" ConceptExpr 	-> ConceptExpr {left, cons("PlusPlus")}
	ConceptExpr "times" ConceptExpr -> ConceptExpr {left, cons("Times")}
	"(" ConceptExpr ")" 			-> ConceptExpr {bracket}

context-free priorities

	ImplExpr Morphism			-> ImplExpr
>
	ImplExpr "times" ImplExpr 	-> ImplExpr
>
{	ImplExpr "*" ImplExpr 		-> ImplExpr
	ImplExpr "**" ImplExpr 		-> ImplExpr
}
>
{	ImplExpr "@" ImplExpr 		-> ImplExpr
	ImplExpr "@@" ImplExpr 		-> ImplExpr
	ImplExpr "+" ImplExpr 		-> ImplExpr
	ImplExpr "++" ImplExpr 		-> ImplExpr
}

context-free priorities

	ConceptExpr Morphism			-> ConceptExpr
>
	ConceptExpr "times" ConceptExpr 	-> ConceptExpr
>
{	ConceptExpr "*" ConceptExpr 		-> ConceptExpr
	ConceptExpr "**" ConceptExpr 		-> ConceptExpr
}
>
{	ConceptExpr "@" ConceptExpr 		-> ConceptExpr
	ConceptExpr "@@" ConceptExpr 		-> ConceptExpr
	ConceptExpr "+" ConceptExpr 		-> ConceptExpr
	ConceptExpr "++" ConceptExpr 		-> ConceptExpr
}
>
	"signature" ConceptExpr				-> ConceptExpr
	