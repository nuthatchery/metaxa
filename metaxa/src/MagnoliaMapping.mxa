language module Magnolia

syntax skin

	AssertClause(: by Expr :)                         -> (+ by Expr +)

	AssertClause(: by simplify Expr :)                -> (+ by simplify Expr +)

	AssertClause(: qed :)                             -> (+ qed +)

	AttrClause(: [ {Attribute ","}* ] :)              -> (+ "[" {Attribute ","}* "]" +)

	Attribute(: Identifier :)                         -> (+ Identifier +)

	Attribute(: Name ( {Expr ","}* ) :)               -> (+ Name "(" {Expr ","}* ")" +)

	AxiomClause(: axiom Identifier FunctionParamList :) -> (+ axiom Identifier FunctionParamList +)

	AxiomClause(: proof Identifier FunctionParamList :) -> (+ proof Identifier FunctionParamList +)

	AxiomClause(: theorem Identifier FunctionParamList :) -> (+ theorem Identifier FunctionParamList +)

	BlockStat(: { Stat* } :)                          -> (+ "{" Stat* "}" +)

	CompileClause(: ID ( {QuotedString ","}* ) ; :)   -> (+ ID "(" {QuotedString ","}* ")" ";" +)

	ConceptClauseArgument(: Type :)                   -> (+ Type +)

	ConsSpec(: Identifier ( {DataRep ","}* ) :)       -> (+ Identifier "(" {DataRep ","}* ")" +)

	ConsSpec(: Identifier :)                          -> (+ Identifier +)

	DataRep(: DecNumeral .. DecNumeral ; :)           -> (+ DecNumeral ".." DecNumeral ";" +)

	DataRep(: struct { Decl* } :)                     -> (+ struct "{" Decl* "}" +)

	DataRep(: type Type ; :)                          -> (+ type Type ";" +)

	DataRep(: union { Decl* } :)                      -> (+ union "{" Decl* "}" +)

	DataRep(: {ConsSpec ","}* ; :)                    -> (+ {ConsSpec ","}* ";" +)

	Decl(: ; :)                                       -> (+ ";" +)

	Decl(: Modifier* ExprDeclarative SubClause* ExprDefBodyS :) -> (+ Modifier* ExprDeclarative SubClause* ExprDefBodyS +)

	Decl(: Modifier* StatDeclarative SubClause* StatDefBodyS :) -> (+ Modifier* StatDeclarative SubClause* StatDefBodyS +)

	Decl(: Modifier* TypeDeclarative SubClause* TypeDefBodyS :) -> (+ Modifier* TypeDeclarative SubClause* TypeDefBodyS +)

	Decl(: Modifier* implementation Identifier SubClause* ImplExpr :) -> (+ Modifier* implementation Identifier SubClause* ImplExpr +)

	Decl(: congruence InstExpr ; :)                   -> (+ congruence InstExpr ";" +)

	Decl(: congruence InstExpr on InstExpr ; :)       -> (+ congruence InstExpr on InstExpr ";" +)

	Decl(: free {Type ","}+ by InstExpr ; :)          -> (+ free {Type ","}+ by InstExpr ";" +)

	Decl(: generate {Type ","}+ by InstExpr ; :)      -> (+ generate {Type ","}+ by InstExpr ";" +)

	Decl(: homomorphism InstExpr on InstExpr with InstExpr ; :) -> (+ homomorphism InstExpr on InstExpr with InstExpr ";" +)

	Decl(: partition {Type ","}+ by InstExpr ; :)     -> (+ partition {Type ","}+ by InstExpr ";" +)

	Decl(: preserve InstExpr ; :)                     -> (+ preserve InstExpr ";" +)

	Decl(: preserve InstExpr on InstExpr ; :)         -> (+ preserve InstExpr on InstExpr ";" +)

	Decl(: requires {InstExpr ","}+ ; :)              -> (+ requires {InstExpr ","}+ ";" +)

	DeclBody(: { Decl* } :)                           -> (+ "{" Decl* "}" +)

	DeclNS(: Modifier* ExprDeclarative SubClause* ExprDefBodyNS :) -> (+ Modifier* ExprDeclarative SubClause* ExprDefBodyNS +)

	DeclNS(: Modifier* StatDeclarative SubClause* StatDefBodyNS :) -> (+ Modifier* StatDeclarative SubClause* StatDefBodyNS +)

	DeclNS(: Modifier* TypeDeclarative SubClause* TypeDefBodyNS :) -> (+ Modifier* TypeDeclarative SubClause* TypeDefBodyNS +)

	Expr(: ( {Expr ","}* ) :)                         -> (+ "(" {Expr ","}* ")" +)

	Expr(: : Type :)                                  -> (+ ":" Type +)

	Expr(: BTNOT Expr :)                              -> (+ BTNOT Expr +)

	Expr(: Expr . DecNumeral :)                       -> (+ Expr "." DecNumeral +)

	Expr(: Expr . Identifier :)                       -> (+ Expr "." Identifier +)

	Expr(: Expr ADDOP Expr :)                         -> (+ Expr ADDOP Expr +)

	Expr(: Expr BITOR Expr :)                         -> (+ Expr BITOR Expr +)

	Expr(: Expr BTAND Expr :)                         -> (+ Expr BTAND Expr +)

	Expr(: Expr BTXOR Expr :)                         -> (+ Expr BTXOR Expr +)

	Expr(: Expr CMPOP Expr :)                         -> (+ Expr CMPOP Expr +)

	Expr(: Expr EQUOP Expr :)                         -> (+ Expr EQUOP Expr +)

	Expr(: Expr LGAND Expr :)                         -> (+ Expr LGAND Expr +)

	Expr(: Expr LGIMP Expr :)                         -> (+ Expr LGIMP Expr +)

	Expr(: Expr LOGOR Expr :)                         -> (+ Expr LOGOR Expr +)

	Expr(: Expr MULOP Expr :)                         -> (+ Expr MULOP Expr +)

	Expr(: Expr RNGOP Expr :)                         -> (+ Expr RNGOP Expr +)

	Expr(: Expr SHFOP Expr :)                         -> (+ Expr SHFOP Expr +)

	Expr(: Expr SUBST Expr :)                         -> (+ Expr SUBST Expr +)

	Expr(: Expr [ {Expr ","}* ] :)                    -> (+ Expr "[" {Expr ","}* "]" +)

	Expr(: Expr in Expr :)                            -> (+ Expr in Expr +)

	Expr(: Expr not in Expr :)                        -> (+ Expr not in Expr +)

	Expr(: Fun ( {Expr ","}* ) :)                     -> (+ Fun "(" {Expr ","}* ")" +)

	Expr(: LGNOT Expr :)                              -> (+ LGNOT Expr +)

	Expr(: Literal :)                                 -> (+ Literal +)

	Expr(: NEGOP Expr :)                              -> (+ NEGOP Expr +)

	Expr(: Name :)                                    -> (+ Name +)

	Expr(: Type $ { {InitSpec ","}* } :)              -> (+ Type "$" "{" {InitSpec ","}* "}" +)

	Expr(: Type { {InitSpec ","}* } :)                -> (+ Type "{" {InitSpec ","}* "}" +)

	Expr(: _ :)                                       -> (+ "_" +)

	Expr(: if Expr then Expr else Expr end :)         -> (+ if Expr then Expr else Expr end +)

	Expr(: { Stat* } :)                               -> (+ "{" Stat* "}" +)

	ExprDefBodyNS(:  :)                               -> (+  +)

	ExprDefBodyNS(: = Expr :)                         -> (+ "=" Expr +)

	ExprDefBodyS(: ; :)                               -> (+ ";" +)

	ExprDefBodyS(: = Expr ; :)                        -> (+ "=" Expr ";" +)

	ExternalExpr(: Identifier Name defines InstExpr :) -> (+ Identifier Name defines InstExpr +)

	ExternalExpr(: Identifier Name extends InstExpr on InstExpr defines InstExpr :) -> (+ Identifier Name extends InstExpr on InstExpr defines InstExpr +)

	ExternalExpr(: Identifier Name on InstExpr defines InstExpr :) -> (+ Identifier Name on InstExpr defines InstExpr +)

	FilterExpr(: remove AlgDeclOrName :)              -> (+ remove AlgDeclOrName +)

	FilterExpr(: retain AlgDeclOrName :)              -> (+ retain AlgDeclOrName +)

	Fun(: FunName :)                                  -> (+ FunName +)

	Fun(: \external ( Identifier , Name ) :)          -> (+ "\external" "(" Identifier "," Name ")" +)

	Fun(: \f ( Name ) :)                              -> (+ "\f" "(" Name ")" +)

	FunClause(: congruence FunctionParamList :)       -> (+ congruence FunctionParamList +)

	FunClause(: dataInvariant FunctionParamList :)    -> (+ "dataInvariant" FunctionParamList +)

	FunClause(: function FunIdentifier FunctionParamList : Type :) -> (+ function FunIdentifier FunctionParamList ":" Type +)

	FunctionParam(: Type :)                           -> (+ Type +)

	FunctionParam(: VarIdentifier : Type :)           -> (+ VarIdentifier ":" Type +)

	FunctionParamList(: ( {FunctionParam ","}* ) :)   -> (+ "(" {FunctionParam ","}* ")" +)

	GuardClause(: guard Expr :)                       -> (+ guard Expr +)

	Identifier(: ID :)                                -> (+ ID +)

	ImportClause(: Name :)                            -> (+ Name +)

	ImportClause(: module Name :)                     -> (+ module Name +)

	ImportClause(: module Name = Name :)              -> (+ module Name "=" Name +)

	InitSpec(: Identifier := Expr :)                  -> (+ Identifier ":=" Expr +)

	InstExpr(: InstExpr ** InstExpr :)                -> (+ InstExpr "**" InstExpr +)

	InstExpr(: InstExpr + InstExpr :)                 -> (+ InstExpr "+" InstExpr +)

	InstExpr(: InstExpr ++ InstExpr :)                -> (+ InstExpr "++" InstExpr +)

	InstExpr(: InstExpr @ InstExpr :)                 -> (+ InstExpr "@" InstExpr +)

	InstExpr(: InstExpr @@ InstExpr :)                -> (+ InstExpr "@@" InstExpr +)

	InstExpr(: InstExpr FilterExpr :)                 -> (+ InstExpr FilterExpr +)

	InstExpr(: InstExpr [ {Renaming ","}* ] :)        -> (+ InstExpr "[" {Renaming ","}* "]" +)

	InstExpr(: InstExpr dataInvariant InstExpr :)     -> (+ InstExpr "dataInvariant" InstExpr +)

	InstExpr(: InstExpr declared Filter :)            -> (+ InstExpr declared Filter +)

	InstExpr(: InstExpr homomorphism InstExpr on InstExpr with InstExpr :) -> (+ InstExpr homomorphism InstExpr on InstExpr with InstExpr +)

	InstExpr(: InstExpr morphism InstExpr :)          -> (+ InstExpr morphism InstExpr +)

	InstExpr(: InstExpr on Filter :)                  -> (+ InstExpr on Filter +)

	InstExpr(: InstExpr protect AlgDeclOrName :)      -> (+ InstExpr protect AlgDeclOrName +)

	InstExpr(: InstExpr quotient InstExpr :)          -> (+ InstExpr quotient InstExpr +)

	InstExpr(: InstExpr times InstExpr :)             -> (+ InstExpr times InstExpr +)

	InstExpr(: [ {Renaming ","}* ] :)                 -> (+ "[" {Renaming ","}* "]" +)

	InstExpr(: declared InstExpr :)                   -> (+ declared InstExpr +)

	InstExpr(: defines AlgDecl :)                     -> (+ defines AlgDecl +)

	InstExpr(: external ExternalExpr :)               -> (+ external ExternalExpr +)

	InstExpr(: full InstExpr :)                       -> (+ full InstExpr +)

	InstExpr(: on InstExpr :)                         -> (+ on InstExpr +)

	InstExpr(: on InstExpr defines AlgDecl :)         -> (+ on InstExpr defines AlgDecl +)

	InstExpr(: signature InstExpr :)                  -> (+ signature InstExpr +)

	LetClause(: var Identifier : Type = Expr ; :)     -> (+ var Identifier ":" Type "=" Expr ";" +)

	Literal(: BinNumeral :)                           -> (+ BinNumeral +)

	Literal(: HexNumeral :)                           -> (+ HexNumeral +)

	Literal(: OctNumeral :)                           -> (+ OctNumeral +)

	Modifier(: abstract :)                            -> (+ abstract +)

	Modifier(: default :)                             -> (+ default +)

	Modifier(: protect :)                             -> (+ protect +)

	ModuleClause(: compile " String " { CompileClause* } :) -> (+ compile """ String """ "{" CompileClause* "}" +)

	ModuleClause(: imports {ImportClause ","}* :)     -> (+ imports {ImportClause ","}* +)

	ModuleClause(: language {Name ","}* :)            -> (+ language {Name ","}* +)

	ModuleClause(: requires {RequiresClause ","}* :)  -> (+ requires {RequiresClause ","}* +)

	ModuleHead(:  :)                                  -> (+  +)

	ModuleHead(: module Name ModuleClause* ; :)       -> (+ module Name ModuleClause* ";" +)

	Name(: ID :)                                      -> (+ ID +)

	Name(: Name . ID :)                               -> (+ Name "." ID +)

	ParamMode(: del :)                                -> (+ del +)

	ParamMode(: exp :)                                -> (+ exp +)

	ParamMode(: giv :)                                -> (+ giv +)

	ParamMode(: nrm :)                                -> (+ nrm +)

	ParamMode(: obs :)                                -> (+ obs +)

	ParamMode(: out :)                                -> (+ out +)

	ParamMode(: upd :)                                -> (+ upd +)

	PredClause(: predicate FunIdentifier FunctionParamList :) -> (+ predicate FunIdentifier FunctionParamList +)

	Proc(: ProcName :)                                -> (+ ProcName +)

	Proc(: \external ( Identifier , Name ) :)         -> (+ "\external" "(" Identifier "," Name ")" +)

	Proc(: \p ( Name ) :)                             -> (+ "\p" "(" Name ")" +)

	ProcClause(: congruence ProcedureParamList :)     -> (+ congruence ProcedureParamList +)

	ProcClause(: dataInvariant ProcedureParamList :)  -> (+ "dataInvariant" ProcedureParamList +)

	ProcClause(: procedure ProcIdentifier ProcedureParamList :) -> (+ procedure ProcIdentifier ProcedureParamList +)

	ProcIdentifier(: _=_ :)                           -> (+ "_=_" +)

	ProcedureParam(: Identifier : Type :)             -> (+ Identifier ":" Type +)

	ProcedureParam(: ParamMode : Type :)              -> (+ ParamMode ":" Type +)

	ProcedureParam(: ParamMode VarIdentifier : Type :) -> (+ ParamMode VarIdentifier ":" Type +)

	ProcedureParamList(: ( {ProcedureParam ","}* ) :) -> (+ "(" {ProcedureParam ","}* ")" +)

	ProdType(: Type , ProdType :)                     -> (+ Type "," ProdType +)

	Program(: ModuleHead TopDecl* :)                  -> (+ ModuleHead TopDecl* +)

	QuotedString(: " String " :)                      -> (+ """ String """ +)

	Renaming(: Name => Name :)                        -> (+ Name "=>" Name +)

	RequiresClause(: Identifier < {ConceptClauseArgument ","}* > :) -> (+ Identifier "<" {ConceptClauseArgument ","}* ">" +)

	SatisfactionExpr(: InstExpr models InstExpr :)    -> (+ InstExpr models InstExpr +)

	SatisfactionExpr(: InstExpr with InstExpr models InstExpr :) -> (+ InstExpr with InstExpr models InstExpr +)

	Stat(: ; :)                                       -> (+ ";" +)

	Stat(: Expr . Identifier = Expr ; :)              -> (+ Expr "." Identifier "=" Expr ";" +)

	Stat(: Expr = Expr ; :)                           -> (+ Expr "=" Expr ";" +)

	Stat(: Identifier [ {Expr ","}+ ] = Expr ; :)     -> (+ Identifier "[" {Expr ","}+ "]" "=" Expr ";" +)

	Stat(: assert Expr AssertClause* ; :)             -> (+ assert Expr AssertClause* ";" +)

	Stat(: break ; :)                                 -> (+ break ";" +)

	Stat(: call Proc ( {Expr ","}* ) ; :)             -> (+ call Proc "(" {Expr ","}* ")" ";" +)

	Stat(: for Identifier in Expr Stat :)             -> (+ for Identifier in Expr Stat +)

	Stat(: for Identifier in Expr do Stat* end :)     -> (+ for Identifier in Expr do Stat* end +)

	Stat(: if ( Expr ) { Stat* } :)                   -> (+ if "(" Expr ")" "{" Stat* "}" +)

	Stat(: if ( Expr ) { Stat* } else { Stat* } :)    -> (+ if "(" Expr ")" "{" Stat* "}" else "{" Stat* "}" +)

	Stat(: if Expr then Stat* else Stat* end :)       -> (+ if Expr then Stat* else Stat* end +)

	Stat(: if Expr then Stat* end :)                  -> (+ if Expr then Stat* end +)

	Stat(: let LetClause* in Stat* end :)             -> (+ let LetClause* in Stat* end +)

	Stat(: open {Identifier ","}* in Stat* end :)     -> (+ open {Identifier ","}* in Stat* end +)

	Stat(: print {Expr ","}* , ; :)                   -> (+ print {Expr ","}* "," ";" +)

	Stat(: print {Expr ","}* ; :)                     -> (+ print {Expr ","}* ";" +)

	Stat(: return ; :)                                -> (+ return ";" +)

	Stat(: return Expr ; :)                           -> (+ return Expr ";" +)

	Stat(: var Identifier : Type ; :)                 -> (+ var Identifier ":" Type ";" +)

	Stat(: var Identifier : Type = Expr ; :)          -> (+ var Identifier ":" Type "=" Expr ";" +)

	Stat(: var Identifier ; :)                        -> (+ var Identifier ";" +)

	Stat(: var Identifier = Expr ; :)                 -> (+ var Identifier "=" Expr ";" +)

	Stat(: while Expr do Stat* end :)                 -> (+ while Expr do Stat* end +)

	Stat(: yield Expr ; :)                            -> (+ yield Expr ";" +)

	StatDefBodyNS(:  :)                               -> (+  +)

	StatDefBodyNS(: = Stat :)                         -> (+ "=" Stat +)

	StatDefBodyS(: ; :)                               -> (+ ";" +)

	StatDefBodyS(: = Stat ; :)                        -> (+ "=" Stat ";" +)

	SubClause(: default ( {Identifier ","}* ) :)      -> (+ default "(" {Identifier ","}* ")" +)

	SubClause(: external :)                           -> (+ external +)

	SubClause(: opens ( {Identifier ","}* ) :)        -> (+ opens "(" {Identifier ","}* ")" +)

	TopDecl(: ; :)                                    -> (+ ";" +)

	TopDecl(: Modifier* concept Identifier SubClause* = InstExpr :) -> (+ Modifier* concept Identifier SubClause* "=" InstExpr +)

	TopDecl(: Modifier* concept Identifier SubClause* DeclBody :) -> (+ Modifier* concept Identifier SubClause* DeclBody +)

	TopDecl(: Modifier* implementation Identifier SubClause* = InstExpr :) -> (+ Modifier* implementation Identifier SubClause* "=" InstExpr +)

	TopDecl(: Modifier* library Identifier SubClause* = InstExpr :) -> (+ Modifier* library Identifier SubClause* "=" InstExpr +)

	TopDecl(: Modifier* satisfaction Identifier SubClause* = SatisfactionExpr :) -> (+ Modifier* satisfaction Identifier SubClause* "=" SatisfactionExpr +)

	Type(: ( ) :)                                     -> (+ "(" ")" +)

	Type(: ( ProdType ) :)                            -> (+ "(" ProdType ")" +)

	Type(: Name :)                                    -> (+ Name +)

	Type(: Type | Type :)                             -> (+ Type "|" Type +)

	Type(: \external ( Identifier , Name ) :)         -> (+ "\external" "(" Identifier "," Name ")" +)

	Type(: struct DeclBody :)                         -> (+ struct DeclBody +)

	TypeClause(: type TypeIdentifier :)               -> (+ type TypeIdentifier +)

	TypeDefBodyNS(:  :)                               -> (+  +)

	TypeDefBodyNS(: = Type :)                         -> (+ "=" Type +)

	TypeDefBodyS(: ; :)                               -> (+ ";" +)

	TypeDefBodyS(: = Type ; :)                        -> (+ "=" Type ";" +)

	Var(: Name : Type :)                              -> (+ Name ":" Type +)

	VarClause(: var VarIdentifier : Type :)           -> (+ var VarIdentifier ":" Type +)



